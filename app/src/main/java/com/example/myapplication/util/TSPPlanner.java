package com.example.myapplication.util;

import com.example.myapplication.data.MowingPlace;

import java.util.ArrayList;
import java.util.List;

public class TSPPlanner {

    /**
     * Generates an ordered route (TSP solution) given a list of nodes and a speed multiplier.
     * This is a stub implementation – replace with a proper Christofides–Serdyukov algorithm.
     *
     * @param nodes List of MowingPlace nodes (including start and end)
     * @param speedMultiplier Speed multiplier to adjust mowing time
     * @return Ordered list representing the route
     */
    public static List<MowingPlace> generateRoute(List<MowingPlace> nodes, double speedMultiplier) {
        // For demonstration, simply return the nodes in the same order.
        // In real implementation, use TSP algorithm to optimize route.
        return nodes;
    }

    /**
     * Optionally adds extra cemeteries to the route if leftover time remains.
     * This is a stub implementation – replace with logic based on priority and time constraints.
     *
     * @param currentRoute The current route generated by TSP.
     * @param allAvailablePlaces All available MowingPlace objects.
     * @param endTime The time constraint at the end location.
     * @param speedMultiplier Speed multiplier applied.
     * @return Updated route with extra cemeteries added if possible.
     */
    public static List<MowingPlace> addExtraCemeteries(List<MowingPlace> currentRoute, List<MowingPlace> allAvailablePlaces, int endTime, double speedMultiplier) {
        // For demonstration, if current route time is less than endTime, add one extra place (if available)
        double currentTime = 0;
        for (MowingPlace mp : currentRoute) {
            currentTime += mp.getTimeRequirement();
        }
        // If there is at least 30 minutes remaining, try to add one extra cemetery not already in route
        if (endTime - currentTime >= 30) {
            for (MowingPlace extra : allAvailablePlaces) {
                boolean alreadyInRoute = false;
                for (MowingPlace mp : currentRoute) {
                    if (mp.getId().equals(extra.getId())) {
                        alreadyInRoute = true;
                        break;
                    }
                }
                if (!alreadyInRoute) {
                    // Adjust the mowing time using the speed multiplier
                    extra.setTimeRequirement(extra.getTimeRequirement() / speedMultiplier);
                    currentRoute.add(currentRoute.size() - 1, extra); // Insert before the end node
                    break;
                }
            }
        }
        return currentRoute;
    }
}
